//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;
using RosMessageTypes.BuiltinInterfaces;

namespace RosMessageTypes.BaxterCore
{
    [Serializable]
    public class EndEffectorStateMsg : Message
    {
        public const string k_RosMessageName = "baxter_core_msgs/EndEffectorState";
        public override string RosMessageName => k_RosMessageName;

        // 
        public TimeMsg timestamp;
        //  time when state was updated
        public uint id;
        //  EndEffectorId
        // 
        //  The following State fields are tristate: 0 = false; 1 = true; 2 = unknown/unsupported
        public const byte STATE_FALSE = 0;
        public const byte STATE_TRUE = 1;
        public const byte STATE_UNKNOWN = 2;
        // 
        public byte enabled;
        //  true if enabled
        public byte calibrated;
        //  true if calibration has completed
        public byte ready;
        //  true if ready for another command
        public byte moving;
        //  true if moving
        public byte gripping;
        //  true if gripping
        public byte missed;
        //  true if GRIP/GOTO/SET was commanded and the gripper reaches the end of travel
        public byte error;
        //  true if the gripper is in an error state
        public byte reverse;
        //  true if the gripper is in reverse mode
        // 
        public float position;
        //  position as a percentage of the max position;      0=closed - 100=open
        // 
        public const float POSITION_CLOSED = 0.0f;
        public const float POSITION_OPEN = 100.0f;
        // 
        public float force;
        //  force as a percentage of max force;                0=none   - 100=max
        // 
        public const float FORCE_MIN = 0.0f;
        public const float FORCE_MAX = 100.0f;
        // 
        public string state;
        //  JSON: other state information
        // 
        public string command;
        //  from the last command message
        public string command_sender;
        public uint command_sequence;
        // 

        public EndEffectorStateMsg()
        {
            this.timestamp = new TimeMsg();
            this.id = 0;
            this.enabled = 0;
            this.calibrated = 0;
            this.ready = 0;
            this.moving = 0;
            this.gripping = 0;
            this.missed = 0;
            this.error = 0;
            this.reverse = 0;
            this.position = 0.0f;
            this.force = 0.0f;
            this.state = "";
            this.command = "";
            this.command_sender = "";
            this.command_sequence = 0;
        }

        public EndEffectorStateMsg(TimeMsg timestamp, uint id, byte enabled, byte calibrated, byte ready, byte moving, byte gripping, byte missed, byte error, byte reverse, float position, float force, string state, string command, string command_sender, uint command_sequence)
        {
            this.timestamp = timestamp;
            this.id = id;
            this.enabled = enabled;
            this.calibrated = calibrated;
            this.ready = ready;
            this.moving = moving;
            this.gripping = gripping;
            this.missed = missed;
            this.error = error;
            this.reverse = reverse;
            this.position = position;
            this.force = force;
            this.state = state;
            this.command = command;
            this.command_sender = command_sender;
            this.command_sequence = command_sequence;
        }

        public static EndEffectorStateMsg Deserialize(MessageDeserializer deserializer) => new EndEffectorStateMsg(deserializer);

        private EndEffectorStateMsg(MessageDeserializer deserializer)
        {
            this.timestamp = TimeMsg.Deserialize(deserializer);
            deserializer.Read(out this.id);
            deserializer.Read(out this.enabled);
            deserializer.Read(out this.calibrated);
            deserializer.Read(out this.ready);
            deserializer.Read(out this.moving);
            deserializer.Read(out this.gripping);
            deserializer.Read(out this.missed);
            deserializer.Read(out this.error);
            deserializer.Read(out this.reverse);
            deserializer.Read(out this.position);
            deserializer.Read(out this.force);
            deserializer.Read(out this.state);
            deserializer.Read(out this.command);
            deserializer.Read(out this.command_sender);
            deserializer.Read(out this.command_sequence);
        }

        public override void SerializeTo(MessageSerializer serializer)
        {
            serializer.Write(this.timestamp);
            serializer.Write(this.id);
            serializer.Write(this.enabled);
            serializer.Write(this.calibrated);
            serializer.Write(this.ready);
            serializer.Write(this.moving);
            serializer.Write(this.gripping);
            serializer.Write(this.missed);
            serializer.Write(this.error);
            serializer.Write(this.reverse);
            serializer.Write(this.position);
            serializer.Write(this.force);
            serializer.Write(this.state);
            serializer.Write(this.command);
            serializer.Write(this.command_sender);
            serializer.Write(this.command_sequence);
        }

        public override string ToString()
        {
            return "EndEffectorStateMsg: " +
            "\ntimestamp: " + timestamp.ToString() +
            "\nid: " + id.ToString() +
            "\nenabled: " + enabled.ToString() +
            "\ncalibrated: " + calibrated.ToString() +
            "\nready: " + ready.ToString() +
            "\nmoving: " + moving.ToString() +
            "\ngripping: " + gripping.ToString() +
            "\nmissed: " + missed.ToString() +
            "\nerror: " + error.ToString() +
            "\nreverse: " + reverse.ToString() +
            "\nposition: " + position.ToString() +
            "\nforce: " + force.ToString() +
            "\nstate: " + state.ToString() +
            "\ncommand: " + command.ToString() +
            "\ncommand_sender: " + command_sender.ToString() +
            "\ncommand_sequence: " + command_sequence.ToString();
        }

#if UNITY_EDITOR
        [UnityEditor.InitializeOnLoadMethod]
#else
        [UnityEngine.RuntimeInitializeOnLoadMethod]
#endif
        public static void Register()
        {
            MessageRegistry.Register(k_RosMessageName, Deserialize);
        }
    }
}
